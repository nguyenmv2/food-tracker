# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `sorbet-rails` gem.
# Please instead update this file by running `bin/tapioca sync`.

# typed: true

module ITypeAssert
  extend T::Generic

  abstract!

  Elem = type_member(:out)

  sig { abstract.params(val: T.untyped).returns(T.untyped) }
  def assert(val); end

  def get_type; end
end

class Parlour::Generator
  sig { params(break_params: Integer, tab_size: Integer, sort_namespaces: T::Boolean).void }
  def initialize(break_params: T.unsafe(nil), tab_size: T.unsafe(nil), sort_namespaces: T.unsafe(nil)); end

  sig { overridable.returns(T.nilable(Parlour::Plugin)) }
  def current_plugin; end

  def current_plugin=(_arg0); end

  sig { overridable.returns(Parlour::Options) }
  def options; end
end

class Parlour::Options
  sig { params(break_params: Integer, tab_size: Integer, sort_namespaces: T::Boolean).void }
  def initialize(break_params:, tab_size:, sort_namespaces:); end

  sig { returns(Integer) }
  def break_params; end

  sig { params(level: Integer, str: String).returns(String) }
  def indented(level, str); end

  sig { returns(T::Boolean) }
  def sort_namespaces; end

  sig { returns(Integer) }
  def tab_size; end
end

class Parlour::Plugin
  abstract!

  sig { params(options: T::Hash[T.untyped, T.untyped]).void }
  def initialize(options); end

  sig { abstract.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end

  sig { returns(T.nilable(String)) }
  def strictness; end

  def strictness=(_arg0); end

  class << self
    sig { params(new_plugin: T.class_of(Parlour::Plugin)).void }
    def inherited(new_plugin); end

    sig { returns(T::Hash[String, T.class_of(Parlour::Plugin)]) }
    def registered_plugins; end

    sig { params(plugins: T::Array[Parlour::Plugin], generator: Parlour::RbiGenerator, allow_failure: T::Boolean).void }
    def run_plugins(plugins, generator, allow_failure: T.unsafe(nil)); end
  end
end

class Parlour::RbiGenerator < ::Parlour::Generator
  def initialize(**hash); end

  sig { overridable.params(strictness: String).returns(String) }
  def rbi(strictness = T.unsafe(nil)); end

  sig { overridable.returns(Parlour::RbiGenerator::Namespace) }
  def root; end
end

class Parlour::RbiGenerator::Arbitrary < ::Parlour::RbiGenerator::RbiObject
  sig { params(generator: Parlour::Generator, code: String, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Arbitrary).void)).void }
  def initialize(generator, code: T.unsafe(nil), &block); end

  sig { params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { returns(String) }
  def code; end

  def code=(_arg0); end

  sig { override.returns(String) }
  def describe; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

class Parlour::RbiGenerator::Attribute < ::Parlour::RbiGenerator::Method
  sig { params(generator: Parlour::Generator, name: String, kind: Symbol, type: T.any(Parlour::Types::Type, String), class_attribute: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Attribute).void)).void }
  def initialize(generator, name, kind, type, class_attribute: T.unsafe(nil), &block); end

  sig { override.params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { returns(T::Boolean) }
  def class_attribute; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { returns(Symbol) }
  def kind; end

  sig { returns(T.any(Parlour::Types::Type, String)) }
  def type; end

  private

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_definition(indent_level, options); end
end

class Parlour::RbiGenerator::ClassNamespace < ::Parlour::RbiGenerator::Namespace
  sig { params(generator: Parlour::Generator, name: String, final: T::Boolean, sealed: T::Boolean, superclass: T.nilable(String), abstract: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::ClassNamespace).void)).void }
  def initialize(generator, name, final, sealed, superclass, abstract, &block); end

  sig { returns(T::Boolean) }
  def abstract; end

  sig { override.returns(String) }
  def describe; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  sig { returns(T.nilable(String)) }
  def superclass; end
end

class Parlour::RbiGenerator::Constant < ::Parlour::RbiGenerator::RbiObject
  sig { params(generator: Parlour::Generator, name: String, value: T.any(Parlour::Types::Type, String), eigen_constant: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Constant).void)).void }
  def initialize(generator, name: T.unsafe(nil), value: T.unsafe(nil), eigen_constant: T.unsafe(nil), &block); end

  sig { params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(String) }
  def describe; end

  def eigen_constant; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  sig { returns(T.any(Parlour::Types::Type, String)) }
  def value; end
end

class Parlour::RbiGenerator::EnumClassNamespace < ::Parlour::RbiGenerator::ClassNamespace
  sig { params(generator: Parlour::Generator, name: String, final: T::Boolean, sealed: T::Boolean, enums: T::Array[T.any(String, [String, String])], abstract: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::EnumClassNamespace).void)).void }
  def initialize(generator, name, final, sealed, enums, abstract, &block); end

  sig { returns(T::Array[T.any(String, [String, String])]) }
  def enums; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_body(indent_level, options); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

class Parlour::RbiGenerator::Extend < ::Parlour::RbiGenerator::RbiObject
  sig { params(generator: Parlour::Generator, name: String, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Extend).void)).void }
  def initialize(generator, name: T.unsafe(nil), &block); end

  sig { params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(String) }
  def describe; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

class Parlour::RbiGenerator::Include < ::Parlour::RbiGenerator::RbiObject
  sig { params(generator: Parlour::Generator, name: String, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Include).void)).void }
  def initialize(generator, name: T.unsafe(nil), &block); end

  sig { params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(String) }
  def describe; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

class Parlour::RbiGenerator::Method < ::Parlour::RbiGenerator::RbiObject
  sig { params(generator: Parlour::Generator, name: String, parameters: T::Array[Parlour::RbiGenerator::Parameter], return_type: T.nilable(T.any(Parlour::Types::Type, String)), abstract: T::Boolean, implementation: T::Boolean, override: T::Boolean, overridable: T::Boolean, class_method: T::Boolean, final: T::Boolean, type_parameters: T.nilable(T::Array[Symbol]), block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Method).void)).void }
  def initialize(generator, name, parameters, return_type = T.unsafe(nil), abstract: T.unsafe(nil), implementation: T.unsafe(nil), override: T.unsafe(nil), overridable: T.unsafe(nil), class_method: T.unsafe(nil), final: T.unsafe(nil), type_parameters: T.unsafe(nil), &block); end

  sig { overridable.params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { returns(T::Boolean) }
  def abstract; end

  sig { returns(T::Boolean) }
  def class_method; end

  sig { override.returns(String) }
  def describe; end

  sig { returns(T::Boolean) }
  def final; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { returns(T::Boolean) }
  def implementation; end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  sig { returns(T::Boolean) }
  def overridable; end

  sig { returns(T::Boolean) }
  def override; end

  sig { returns(T::Array[Parlour::RbiGenerator::Parameter]) }
  def parameters; end

  sig { returns(T.nilable(T.any(Parlour::Types::Type, String))) }
  def return_type; end

  sig { returns(T::Array[Symbol]) }
  def type_parameters; end

  private

  sig { overridable.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_definition(indent_level, options); end

  sig { returns(String) }
  def qualifiers; end
end

class Parlour::RbiGenerator::ModuleNamespace < ::Parlour::RbiGenerator::Namespace
  sig { params(generator: Parlour::Generator, name: String, final: T::Boolean, sealed: T::Boolean, interface: T::Boolean, abstract: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::ClassNamespace).void)).void }
  def initialize(generator, name, final, sealed, interface, abstract, &block); end

  sig { returns(T::Boolean) }
  def abstract; end

  sig { override.returns(String) }
  def describe; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { returns(T::Boolean) }
  def interface; end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

class Parlour::RbiGenerator::Namespace < ::Parlour::RbiGenerator::RbiObject
  sig { params(generator: Parlour::Generator, name: T.nilable(String), final: T::Boolean, sealed: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Namespace).void)).void }
  def initialize(generator, name = T.unsafe(nil), final = T.unsafe(nil), sealed = T.unsafe(nil), &block); end

  sig { params(comment: T.any(String, T::Array[String])).void }
  def add_comment_to_next_child(comment); end

  sig { returns(T::Array[Parlour::RbiGenerator::TypeAlias]) }
  def aliases; end

  sig { returns(T::Array[Parlour::RbiGenerator::RbiObject]) }
  def children; end

  sig { returns(T::Array[Parlour::RbiGenerator::Constant]) }
  def constants; end

  def create_arbitrary(code:, &block); end
  def create_attr(*args, &blk); end

  sig { params(name: String, type: T.any(Parlour::Types::Type, String), class_attribute: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Attribute).void)).returns(Parlour::RbiGenerator::Attribute) }
  def create_attr_accessor(name, type:, class_attribute: T.unsafe(nil), &block); end

  sig { params(name: String, type: T.any(Parlour::Types::Type, String), class_attribute: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Attribute).void)).returns(Parlour::RbiGenerator::Attribute) }
  def create_attr_reader(name, type:, class_attribute: T.unsafe(nil), &block); end

  sig { params(name: String, type: T.any(Parlour::Types::Type, String), class_attribute: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Attribute).void)).returns(Parlour::RbiGenerator::Attribute) }
  def create_attr_writer(name, type:, class_attribute: T.unsafe(nil), &block); end

  sig { params(name: String, kind: Symbol, type: T.any(Parlour::Types::Type, String), class_attribute: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Attribute).void)).returns(Parlour::RbiGenerator::Attribute) }
  def create_attribute(name, kind:, type:, class_attribute: T.unsafe(nil), &block); end

  sig { params(name: String, final: T::Boolean, sealed: T::Boolean, superclass: T.nilable(String), abstract: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::ClassNamespace).void)).returns(Parlour::RbiGenerator::ClassNamespace) }
  def create_class(name, final: T.unsafe(nil), sealed: T.unsafe(nil), superclass: T.unsafe(nil), abstract: T.unsafe(nil), &block); end

  sig { params(name: String, value: String, eigen_constant: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Constant).void)).returns(Parlour::RbiGenerator::Constant) }
  def create_constant(name, value:, eigen_constant: T.unsafe(nil), &block); end

  sig { params(name: String, final: T::Boolean, sealed: T::Boolean, enums: T.nilable(T::Array[T.any(String, [String, String])]), abstract: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::EnumClassNamespace).void)).returns(Parlour::RbiGenerator::EnumClassNamespace) }
  def create_enum_class(name, final: T.unsafe(nil), sealed: T.unsafe(nil), enums: T.unsafe(nil), abstract: T.unsafe(nil), &block); end

  sig { params(name: String, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Extend).void)).returns(Parlour::RbiGenerator::Extend) }
  def create_extend(name, &block); end

  sig { params(extendables: T::Array[String]).returns(T::Array[Parlour::RbiGenerator::Extend]) }
  def create_extends(extendables); end

  sig { params(name: String, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Include).void)).returns(Parlour::RbiGenerator::Include) }
  def create_include(name, &block); end

  sig { params(includables: T::Array[String]).returns(T::Array[Parlour::RbiGenerator::Include]) }
  def create_includes(includables); end

  sig { params(name: String, parameters: T.nilable(T::Array[Parlour::RbiGenerator::Parameter]), return_type: T.nilable(T.any(Parlour::Types::Type, String)), returns: T.nilable(T.any(Parlour::Types::Type, String)), abstract: T::Boolean, implementation: T::Boolean, override: T::Boolean, overridable: T::Boolean, class_method: T::Boolean, final: T::Boolean, type_parameters: T.nilable(T::Array[Symbol]), block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::Method).void)).returns(Parlour::RbiGenerator::Method) }
  def create_method(name, parameters: T.unsafe(nil), return_type: T.unsafe(nil), returns: T.unsafe(nil), abstract: T.unsafe(nil), implementation: T.unsafe(nil), override: T.unsafe(nil), overridable: T.unsafe(nil), class_method: T.unsafe(nil), final: T.unsafe(nil), type_parameters: T.unsafe(nil), &block); end

  sig { params(name: String, final: T::Boolean, sealed: T::Boolean, interface: T::Boolean, abstract: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::ClassNamespace).void)).returns(Parlour::RbiGenerator::ModuleNamespace) }
  def create_module(name, final: T.unsafe(nil), sealed: T.unsafe(nil), interface: T.unsafe(nil), abstract: T.unsafe(nil), &block); end

  sig { params(name: String, final: T::Boolean, sealed: T::Boolean, props: T.nilable(T::Array[Parlour::RbiGenerator::StructProp]), abstract: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::StructClassNamespace).void)).returns(Parlour::RbiGenerator::StructClassNamespace) }
  def create_struct_class(name, final: T.unsafe(nil), sealed: T.unsafe(nil), props: T.unsafe(nil), abstract: T.unsafe(nil), &block); end

  sig { params(name: String, type: T.any(Parlour::Types::Type, String), block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::TypeAlias).void)).returns(Parlour::RbiGenerator::TypeAlias) }
  def create_type_alias(name, type:, &block); end

  sig { override.overridable.returns(String) }
  def describe; end

  sig { returns(T::Array[Parlour::RbiGenerator::Extend]) }
  def extends; end

  sig { returns(T::Boolean) }
  def final; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.overridable.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { returns(T::Array[Parlour::RbiGenerator::Include]) }
  def includes; end

  sig { override.overridable.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.overridable.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  sig { params(constant: Module, block: T.proc.params(x: Parlour::RbiGenerator::Namespace).void).void }
  def path(constant, &block); end

  sig { returns(T::Boolean) }
  def sealed; end

  def type_aliases(*args, &blk); end

  private

  sig { overridable.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_body(indent_level, options); end

  sig { params(object: Parlour::RbiGenerator::RbiObject).void }
  def move_next_comments(object); end
end

Parlour::RbiGenerator::Options = Parlour::Options

class Parlour::RbiGenerator::Parameter
  sig { params(name: String, type: T.nilable(T.any(Parlour::Types::Type, String)), default: T.nilable(String)).void }
  def initialize(name, type: T.unsafe(nil), default: T.unsafe(nil)); end

  sig { params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { returns(T.nilable(String)) }
  def default; end

  sig { void }
  def generalize_from_rbi!; end

  sig { returns(Symbol) }
  def kind; end

  sig { returns(String) }
  def name; end

  sig { returns(String) }
  def name_without_kind; end

  sig { returns(String) }
  def to_def_param; end

  sig { returns(String) }
  def to_sig_param; end

  sig { returns(T.any(Parlour::Types::Type, String)) }
  def type; end
end

Parlour::RbiGenerator::Parameter::PREFIXES = T.let(T.unsafe(nil), Hash)

class Parlour::RbiGenerator::RbiObject < ::Parlour::TypedObject
  abstract!

  sig { params(generator: Parlour::Generator, name: String).void }
  def initialize(generator, name); end

  sig { override.overridable.returns(String) }
  def describe; end

  sig { abstract.void }
  def generalize_from_rbi!; end

  sig { abstract.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { returns(Parlour::Generator) }
  def generator; end

  sig { abstract.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { abstract.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end
end

class Parlour::RbiGenerator::StructClassNamespace < ::Parlour::RbiGenerator::ClassNamespace
  sig { params(generator: Parlour::Generator, name: String, final: T::Boolean, sealed: T::Boolean, props: T::Array[Parlour::RbiGenerator::StructProp], abstract: T::Boolean, block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::StructClassNamespace).void)).void }
  def initialize(generator, name, final, sealed, props, abstract, &block); end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_body(indent_level, options); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  sig { returns(T::Array[Parlour::RbiGenerator::StructProp]) }
  def props; end
end

class Parlour::RbiGenerator::StructProp
  sig { params(name: String, type: T.any(Parlour::Types::Type, String), optional: T.nilable(T.any(Symbol, T::Boolean)), enum: T.nilable(String), dont_store: T.nilable(T::Boolean), foreign: T.nilable(String), default: T.nilable(String), factory: T.nilable(String), immutable: T.nilable(T::Boolean), array: T.nilable(String), override: T.nilable(T::Boolean), redaction: T.nilable(String)).void }
  def initialize(name, type, optional: T.unsafe(nil), enum: T.unsafe(nil), dont_store: T.unsafe(nil), foreign: T.unsafe(nil), default: T.unsafe(nil), factory: T.unsafe(nil), immutable: T.unsafe(nil), array: T.unsafe(nil), override: T.unsafe(nil), redaction: T.unsafe(nil)); end

  sig { params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { returns(T.nilable(String)) }
  def array; end

  sig { returns(T.nilable(String)) }
  def default; end

  sig { returns(T.nilable(T::Boolean)) }
  def dont_store; end

  sig { returns(T.nilable(String)) }
  def enum; end

  sig { returns(T.nilable(String)) }
  def factory; end

  sig { returns(T.nilable(String)) }
  def foreign; end

  sig { void }
  def generalize_from_rbi!; end

  sig { returns(T.nilable(T::Boolean)) }
  def immutable; end

  sig { returns(String) }
  def name; end

  sig { returns(T.nilable(T.any(Symbol, T::Boolean))) }
  def optional; end

  sig { returns(T.nilable(T::Boolean)) }
  def override; end

  sig { returns(T.nilable(String)) }
  def redaction; end

  sig { returns(String) }
  def to_prop_call; end

  sig { returns(T.any(Parlour::Types::Type, String)) }
  def type; end
end

Parlour::RbiGenerator::StructProp::EXTRA_PROPERTIES = T.let(T.unsafe(nil), Array)

class Parlour::RbiGenerator::TypeAlias < ::Parlour::RbiGenerator::RbiObject
  sig { params(generator: Parlour::Generator, name: String, type: T.any(Parlour::Types::Type, String), block: T.nilable(T.proc.params(x: Parlour::RbiGenerator::TypeAlias).void)).void }
  def initialize(generator, name:, type:, &block); end

  sig { params(other: Object).returns(T::Boolean) }
  def ==(other); end

  sig { override.returns(String) }
  def describe; end

  sig { override.void }
  def generalize_from_rbi!; end

  sig { override.params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_rbi(indent_level, options); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).void }
  def merge_into_self(others); end

  sig { override.params(others: T::Array[Parlour::RbiGenerator::RbiObject]).returns(T::Boolean) }
  def mergeable?(others); end

  sig { returns(T.any(Parlour::Types::Type, String)) }
  def type; end
end

class Parlour::TypedObject
  abstract!

  sig { params(name: String).void }
  def initialize(name); end

  sig { params(comment: T.any(String, T::Array[String])).void }
  def add_comment(comment); end

  def add_comments(*args, &blk); end

  sig { returns(T::Array[String]) }
  def comments; end

  sig { abstract.returns(String) }
  def describe; end

  sig { returns(T.nilable(Parlour::Plugin)) }
  def generated_by; end

  sig { returns(String) }
  def name; end

  protected

  sig { params(indent_level: Integer, options: Parlour::Options).returns(T::Array[String]) }
  def generate_comments(indent_level, options); end
end

module SorbetRails
  class << self
    sig { returns(SorbetRails::Config) }
    def config; end

    sig { params(blk: T.proc.params(arg0: SorbetRails::Config).void).void }
    def configure(&blk); end

    sig { void }
    def register_configured_plugins; end
  end
end

class SorbetRails::Config
  sig { void }
  def initialize; end

  sig { returns(T::Array[Symbol]) }
  def enabled_gem_plugins; end

  def enabled_gem_plugins=(_arg0); end

  sig { returns(T::Array[Symbol]) }
  def enabled_model_plugins; end

  def enabled_model_plugins=(_arg0); end

  sig { returns(T::Array[Symbol]) }
  def enabled_plugins; end

  sig { returns(T::Array[String]) }
  def extra_helper_includes; end

  def extra_helper_includes=(_arg0); end

  sig { returns(T.class_of(SorbetRails::JobRbiFormatter)) }
  def job_generator_class; end

  def job_generator_class=(_arg0); end

  sig { returns(T.class_of(SorbetRails::MailerRbiFormatter)) }
  def mailer_generator_class; end

  def mailer_generator_class=(_arg0); end
end

class SorbetRails::JobRbiFormatter
  sig { params(job_class: T.class_of(ActiveJob::Base)).void }
  def initialize(job_class); end

  sig { returns(String) }
  def generate_rbi; end

  sig { returns(T.class_of(ActiveJob::Base)) }
  def job_class; end

  sig { void }
  def populate_rbi; end

  sig { returns(Parlour::RbiGenerator) }
  def rbi_generator; end
end

SorbetRails::JobRbiFormatter::Parameter = Parlour::RbiGenerator::Parameter

class SorbetRails::MailerRbiFormatter
  sig { params(mailer_class: T.class_of(ActionMailer::Base)).void }
  def initialize(mailer_class); end

  sig { returns(String) }
  def generate_rbi; end

  sig { returns(T.class_of(ActionMailer::Base)) }
  def mailer_class; end

  sig { void }
  def populate_rbi; end

  sig { returns(Parlour::RbiGenerator) }
  def rbi_generator; end
end

SorbetRails::MailerRbiFormatter::Parameter = Parlour::RbiGenerator::Parameter

module SorbetRails::ModelColumnUtils
  abstract!

  sig { params(klass: Object, time_zone_aware: T::Boolean).returns(T.any(Class, String)) }
  def active_record_type_to_sorbet_type(klass, time_zone_aware: T.unsafe(nil)); end

  sig { params(attribute: T.any(String, Symbol)).returns(T::Boolean) }
  def attribute_has_unconditional_presence_validation?(attribute); end

  sig { abstract.returns(T.any(T.class_of(ActiveRecord::Base), T.class_of(Class))) }
  def model_class; end

  sig { params(column_def: T.untyped).returns(T::Boolean) }
  def nilable_column?(column_def); end

  sig { params(column_def: T.untyped, cast_type: T.untyped).returns(T::Boolean) }
  def time_zone_aware_column?(column_def, cast_type); end

  sig { params(column_def: T.untyped).returns(SorbetRails::ModelColumnUtils::ColumnType) }
  def type_for_column_def(column_def); end
end

class SorbetRails::ModelColumnUtils::ColumnType < ::T::Struct
  const :array_type, T.nilable(T::Boolean)
  const :base_type, T.any(Class, String)
  const :nilable, T.nilable(T::Boolean)

  sig { returns(String) }
  def to_s; end

  class << self
    def inherited(s); end
  end
end

module SorbetRails::ModelPlugins
  sig { params(plugin_name: Symbol).returns(T.class_of(SorbetRails::ModelPlugins::Base)) }
  def get_plugin_by_name(plugin_name); end

  sig { returns(T::Array[T.class_of(SorbetRails::ModelPlugins::Base)]) }
  def get_plugins; end

  sig { params(plugin: T.class_of(SorbetRails::ModelPlugins::Base)).void }
  def register_plugin(plugin); end

  sig { params(plugin_name: Symbol).void }
  def register_plugin_by_name(plugin_name); end

  sig { params(plugins: T::Array[T.class_of(SorbetRails::ModelPlugins::Base)]).void }
  def set_plugins(plugins); end
end

class SorbetRails::ModelPlugins::ActiveRecordAssoc < ::SorbetRails::ModelPlugins::Base
  sig { params(model_class: T.class_of(ActiveRecord::Base), available_classes: T::Set[String]).void }
  def initialize(model_class, available_classes); end

  sig { params(reflection: T.untyped).returns(T.nilable(T::Boolean)) }
  def assoc_should_be_untyped?(reflection); end

  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end

  sig { params(reflection: T.untyped).returns(T.nilable(T::Boolean)) }
  def polymorphic_assoc?(reflection); end

  sig { params(assoc_module_rbi: T.untyped, assoc_name: T.untyped, reflection: T.untyped).void }
  def populate_collection_assoc_getter_setter(assoc_module_rbi, assoc_name, reflection); end

  sig { params(assoc_module_rbi: T.untyped, assoc_name: T.untyped, reflection: T.untyped).void }
  def populate_single_assoc_getter_setter(assoc_module_rbi, assoc_name, reflection); end

  sig { params(reflection: T.untyped).returns(T.nilable(T::Boolean)) }
  def relation_should_be_untyped?(reflection); end

  private

  sig { params(reflection: T.untyped).returns(T::Boolean) }
  def belongs_to_and_required?(reflection); end

  sig { params(reflection: T.untyped).returns(T::Boolean) }
  def has_one_and_required?(reflection); end
end

class SorbetRails::ModelPlugins::ActiveRecordAttribute < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end

  sig { params(root: Parlour::RbiGenerator::Namespace, model_class_rbi: Parlour::RbiGenerator::Namespace, attribute_module_rbi: Parlour::RbiGenerator::Namespace, model_defined_enums: T::Hash[String, T::Hash[String, T.untyped]], column_name: String, column_def: T.untyped).void }
  def generate_enum_methods(root, model_class_rbi, attribute_module_rbi, model_defined_enums, column_name, column_def); end

  sig { params(column_type: SorbetRails::ModelColumnUtils::ColumnType).returns(String) }
  def value_type_for_attr_writer(column_type); end
end

class SorbetRails::ModelPlugins::ActiveRecordEnum < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::ActiveRecordNamedScope < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::ActiveRecordQuerying < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end

  private

  sig { params(root: Parlour::RbiGenerator::Namespace, inner_type: String).void }
  def create_in_batches_method(root, inner_type:); end
end

class SorbetRails::ModelPlugins::ActiveRecordSerializedAttribute < ::SorbetRails::ModelPlugins::Base
  sig { params(columns_hash: T::Hash[String, ActiveRecord::ConnectionAdapters::Column]).returns(T::Boolean) }
  def any_serialized_columns?(columns_hash); end

  sig { params(serialization_coder: T.nilable(Class)).returns(String) }
  def attr_types_for_coder(serialization_coder); end

  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::ActiveRelationWhereNot < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::ActiveStorageMethods < ::SorbetRails::ModelPlugins::Base
  sig { params(model_class: T.class_of(ActiveRecord::Base), available_classes: T::Set[String]).void }
  def initialize(model_class, available_classes); end

  sig { params(assoc_name: String, mod: Parlour::RbiGenerator::Namespace).void }
  def create_has_many_methods(assoc_name, mod); end

  sig { params(assoc_name: String, mod: Parlour::RbiGenerator::Namespace).void }
  def create_has_one_methods(assoc_name, mod); end

  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::Base < ::Parlour::Plugin
  include ::SorbetRails::ModelColumnUtils
  include ::SorbetRails::ModelUtils

  abstract!

  sig { params(model_class: T.class_of(ActiveRecord::Base), available_classes: T::Set[String]).void }
  def initialize(model_class, available_classes); end

  sig { returns(T::Set[String]) }
  def available_classes; end

  sig { override.returns(T.class_of(ActiveRecord::Base)) }
  def model_class; end

  sig { params(column_name: String).returns(T.nilable(Class)) }
  def serialization_coder_for_column(column_name); end
end

SorbetRails::ModelPlugins::Base::Parameter = Parlour::RbiGenerator::Parameter

class SorbetRails::ModelPlugins::CustomFinderMethods < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::EnumerableCollections < ::SorbetRails::ModelPlugins::Base
  sig { override.params(root: Parlour::RbiGenerator::Namespace).void }
  def generate(root); end
end

class SorbetRails::ModelPlugins::UnrecognizedPluginName < ::StandardError; end

class SorbetRails::ModelRbiFormatter
  include ::SorbetRails::ModelColumnUtils
  include ::SorbetRails::ModelUtils
  extend ::SorbetRails::ModelPlugins

  sig { params(model_class: T.class_of(ActiveRecord::Base), available_classes: T::Set[String]).void }
  def initialize(model_class, available_classes); end

  sig { returns(T::Set[String]) }
  def available_classes; end

  sig { params(root: Parlour::RbiGenerator::Namespace).void }
  def generate_base_rbi(root); end

  sig { returns(String) }
  def generate_rbi; end

  sig { override.returns(T.class_of(ActiveRecord::Base)) }
  def model_class; end

  sig { params(plugins: T::Array[Parlour::Plugin], generator: Parlour::RbiGenerator).void }
  def run_plugins(plugins, generator); end
end

module SorbetRails::ModelUtils
  include ::SorbetRails::ModelColumnUtils

  abstract!

  sig { params(root: Parlour::RbiGenerator::Namespace, method_name: String, parameters: T.nilable(T::Array[Parlour::RbiGenerator::Parameter]), builtin_query_method: T::Boolean).void }
  def add_relation_query_method(root, method_name, parameters: T.unsafe(nil), builtin_query_method: T.unsafe(nil)); end

  sig { params(method_name: T.any(String, Symbol)).returns(T::Boolean) }
  def exists_class_method?(method_name); end

  sig { params(method_name: T.any(String, Symbol)).returns(T::Boolean) }
  def exists_instance_method?(method_name); end

  sig { returns(T::Boolean) }
  def habtm_class?; end

  sig { returns(String) }
  def model_assoc_proxy_class_name; end

  sig { returns(String) }
  def model_assoc_relation_class_name; end

  sig { returns(String) }
  def model_class_name; end

  sig { params(module_name: String).returns(String) }
  def model_module_name(module_name); end

  sig { returns(String) }
  def model_query_methods_returning_assoc_relation_module_name; end

  sig { returns(String) }
  def model_query_methods_returning_relation_module_name; end

  sig { returns(String) }
  def model_relation_class_name; end

  sig { returns(String) }
  def model_relation_type_alias; end

  sig { returns(String) }
  def model_relation_type_class_name; end
end

class SorbetRails::Railtie < ::Rails::Railtie; end

module SorbetRails::SorbetUtils
  class << self
    sig { params(parsed_params: T::Array[SorbetRails::SorbetUtils::ParsedParamDef], method_def: UnboundMethod).void }
    def extract_default_value_for_params!(parsed_params, method_def); end

    sig { params(signature: T::Private::Methods::Signature).returns(T::Array[SorbetRails::SorbetUtils::ParsedParamDef]) }
    def get_ordered_parameters_with_type(signature); end

    sig { params(node: T.nilable(Parser::AST::Node)).returns(T.nilable(String)) }
    def node_to_s(node); end

    sig { params(method_def: UnboundMethod).returns(T::Array[Parlour::RbiGenerator::Parameter]) }
    def parameters_from_method_def(method_def); end
  end
end

class SorbetRails::SorbetUtils::ParsedParamDef < ::T::Struct
  prop :default, T.nilable(String), default: T.unsafe(nil)
  const :kind, Symbol
  const :name, Symbol
  prop :prefix, T.nilable(String)
  prop :suffix, T.nilable(String)
  const :type_str, String

  class << self
    def inherited(s); end
  end
end

class SorbetRails::SorbetUtils::UnexpectedParam < ::StandardError; end

module SorbetRails::Utils
  class << self
    sig { void }
    def rails_eager_load_all!; end

    sig { params(method_name: String).returns(T::Boolean) }
    def valid_method_name?(method_name); end
  end
end

class T::Private::Methods::Signature
  def initialize(method:, method_name:, raw_arg_types:, raw_return_type:, bind:, mode:, check_level:, on_failure:, parameters: T.unsafe(nil), override_allow_incompatible: T.unsafe(nil), defined_raw: T.unsafe(nil)); end

  def arg_count; end
  def arg_types; end
  def as_alias(alias_name); end
  def bind; end
  def block_name; end
  def block_type; end
  def check_level; end
  def defined_raw; end
  def dsl_method; end
  def each_args_value_type(args); end
  def has_keyrest; end
  def has_rest; end
  def keyrest_name; end
  def keyrest_type; end
  def kwarg_names; end
  def kwarg_types; end
  def method; end
  def method_desc; end
  def method_name; end
  def mode; end
  def on_failure; end
  def override_allow_incompatible; end
  def owner; end
  def parameters; end
  def req_arg_count; end
  def req_kwarg_names; end
  def rest_name; end
  def rest_type; end
  def return_type; end

  protected

  def method_name=(_arg0); end

  class << self
    def new_untyped(method:, mode: T.unsafe(nil), parameters: T.unsafe(nil)); end
  end
end

T::Private::Methods::Signature::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

class TA
  extend T::Generic
  include ::TypeAssertImpl
  include ::ITypeAssert

  Elem = type_member

  sig { override.params(val: T.untyped).returns(T.untyped) }
  def assert(val); end

  class << self
    def [](type); end
  end
end

module TypeAssertImpl
  class << self
    def included(klass); end
  end
end
